

* [4. Higher-order Programming](hop/intro.md)
  - [4.1. The Meaning of "Higher Order"](hop/higher_order.md)
  - [4.2. The Abstraction Principle](hop/abstraction_principle.md)
  - [4.3. Famous Higher-order Functions](hop/famous_hof.md)
	+ [4.3.1. Map](hop/map.md)
	+ [4.3.2. Filter](hop/filter.md)
	+ [4.3.3. Fold Right](hop/fold_right.md)
	+ [4.3.4. Fold Left](hop/fold_left.md)
	+ [4.3.5. Fold Left vs. Fold Right](hop/fold_left_vs_right.md)
	+ [4.3.6. Using Fold](hop/using_fold.md)
	+ [4.3.7. Fold vs. Recursive vs. Library](hop/fold_vs_rec_vs_lib.md)
	+ [4.3.8. Fold with Trees](hop/fold_trees.md)
	+ [4.3.9. Generalized Folds](hop/generalized_fold.md)
  - [4.4. Pipelining](hop/pipelining.md)
  - [4.5. Currying](hop/currying.md)
  - [4.6. Summary](hop/summary.md)
  - [4.7. Exercises](hop/exercises.md)

* [5. Modules](modules/intro.md)
  - [5.1. Module Systems](modules/module_systems.md)
  - [5.2. OCaml Modules](modules/ocaml_modules.md)
    + [5.2.1. Structures](modules/structures.md)
	+ [5.2.2. Scope](modules/scope.md)
	+ [5.2.3. Signatures](modules/signatures.md)
    + [5.2.4. Abstract Types](modules/abstract_types.md)
    + [5.2.5. Semantics of Modules](modules/semantics_modules.md)
    + [5.2.6. Functional Data Structures](modules/functional_data_structures.md)
	  * [5.2.6.1. Example: Stacks](modules/ex_stacks.md)
	  * [5.2.6.2. Example: Queues](modules/ex_queues.md)
	  * [5.2.6.3. Example: Dictionaries](modules/ex_dictionaries.md)
	  * [5.2.6.4. Example: Sets](modules/ex_sets.md)
	  * [5.2.6.5. Example: Arithmetic](modules/ex_arithmetic.md)
    + [5.2.7. Sharing Constraints](modules/sharing_constraints.md)
    + [5.2.8. Compilation Units](modules/compilation_units.md)
    + [5.2.9. Modules and the Toplevel](modules/toplevel.md)
  - [5.3. Code Reuse with Modules](modules/reuse.md)
	+ [5.3.1. Includes](modules/includes.md)
	  * [5.3.1.1. Semantics of Includes](modules/semantics_includes.md)
	  * [5.3.1.2. Encapsulation and Includes](modules/encapsulation_includes.md)
	  * [5.3.1.3. Include vs. Open](modules/include_vs_open.md)
	  * [5.3.1.4. Including Code in Multiple Modules](modules/include_multiple.md)
	* [5.3.2. Functors](modules/functors.md)
	  * [5.3.2.1. Functor Syntax](modules/functor_syntax.md)
	  * [5.3.2.2. Using Functors](modules/using_functors.md)
	  * [5.3.2.3. Example: Standard Library Map](modules/stdlib_map.md)
  - [5.4. Summary](modules/summary.md)
  - [5.5. Exercises](modules/exercises.md)

* [6. Specifications and Abstraction](abstract/intro.md)
  - [6.1. Specification of Functions](abstract/function_specs.md)
  - [6.2. The Specification Game](abstract/game.md)
  - [6.3. Comments](abstract/comments.md)
  - [6.4. Specification of Modules](abstract/module_specs.md)
  - [6.5. Abstraction Functions](abstract/af.md)
  - [6.6. Commutative Diagrams](abstract/commutative.md)
  - [6.7. Representation Invariants](abstract/ri.md)
  - [6.8. Implementing the Representation Invariant](abstract/impl_ri.md)
  - [6.9. Summary](abstract/summary.md)
  - [6.10. Exercises](abstract/exercises.md)

* [7. Testing](testing/intro.md)
  - [7.1. Test Coverage](testing/coverage.md)
  - [7.2. Black-box Testing](testing/blackbox.md)
  - [7.3. Glass-box Testing](testing/glassbox.md)
  - [7.4. Bisect](testing/bisect.md)
  - [7.5. Testing Data Abstractions](testing/data_abstractions.md)
  - [7.6. Faults](testing/faults.md)
  - [7.7. Randomized Testing](testing/randomized.md)
  - [7.8. Random Number Generation](testing/random.md)
  - [7.9. \*QCheck](testing/qcheck.md)
  - [7.10. Summary](testing/summary.md)
  - [7.11. Exercises](testing/exercises.md)

- [8. Mutability](mut/intro.md)
  - [8.1. Refs](mut/refs.md)
  - [8.2. Refs: Syntax and Semantics](mut/refs_ss.md)
  - [8.3. Sequencing](mut/sequencing.md)
  - [8.4. Example: Mutable Counter](mut/ex_counter.md)
  - [8.5. Example: Recursion Without Rec](mut/ex_recursion_without_rec.md)
  - [8.6. Physical Equality](mut/physical_equality.md)
  - [8.7. Mutable Fields](mut/mutable_fields.md)
  - [8.8. Example: Mutable Stack](mut/ex_mutable_stack.md)
  - [8.9. Arrays and Loops](mut/arrays.md)
  - [8.10. Summary](mut/summary.md)
  - [8.11. Exercises](mut/exercises.md)

- [9. Efficiency](eff/intro.md)
  - [9.1. Defining Efficiency](eff/defining.md)
    - [9.1.1 Algorithms and Efficiency, Attempt 1](eff/eff1.md)
    - [9.1.2 Algorithms and Efficiency, Attempt 2](eff/eff2.md)
    - [9.1.3 Big-Oh Notation](eff/bigoh.md)
    - [9.1.4 Algorithms and Efficiency, Attempt 3](eff/eff3.md)
  - [9.2. Efficient Maps](eff/eff_maps.md)
    - [9.2.1. Association Lists](eff/map_assoclist.md)
    - [9.2.2. Direct Address Tables](eff/map_dat.md)
    - [9.2.3. Hash Tables](eff/map_hash.md)
  - [9.3. Amortized Analysis](eff/amortized.md)
    - [9.3.1. Amortized Analysis of Hash Tables](eff/amortized_hash.md)
    - [9.3.2. Amortized Analysis of Two-List Queues](eff/amortized_queue.md)
    - [9.3.3. Bankers and Physicists](eff/amortized_methods.md)
    - [9.3.4. Amortized Analysis and Persistence](eff/amortized_persistence.md)
  - [9.4. Functional Maps](eff/funmaps.md)
     - [9.4.1. Binary Search Trees](eff/bst.md)
     - [9.4.2. Red-Black Trees](eff/rb.md)
     - [9.4.3. Maps and Sets from BSTs](eff/bst_maps.md)
  - [9.5. Summary](eff/summary.md)
  - [9.6. Exercises](eff/exercises.md)

* [10. Interpreters](interp/intro.md)
  - [10.1. Lexing and Parsing](interp/lex_parse.md)
    - [10.1.1. Backus-Naur Form](interp/bnf.md)
	  - [10.1.2. Example: SimPL](interp/simpl.md)
	  - [10.1.3. A Front-End for SimPL](interp/simpl_frontend.md)
  - [10.2. Evaluation: The Substitution Model](interp/evaluation.md)
	  - [10.2.1. Evaluating SimPL in the Substitution Model](interp/simpl_subst_model.md)
	  - [10.2.2. Substitution in SimPL](interp/subst_simpl.md)
	  - [10.2.3. Capture-Avoiding Substitution](interp/subst_lambda.md)
	  - [10.2.4. Core OCaml](interp/core_ocaml.md)
	  - [10.2.5. Evaluating Core OCaml in the Substitution Model](interp/core_ocaml_subst_model.md)
  - [10.3. Evaluation: The Environment Model](interp/env_model.md)
	  - [10.3.1. Evaluating the Lambda Calculus in the Environment Model](interp/lambda_env_model.md)
	  - [10.3.2. Evaluating Core OCaml in the Environment Model](interp/core_ocaml_env_model.md)
  - [10.4. Type Checking](interp/typecheck.md)
	  - [10.4.1. A Type System for SimPL](interp/simpl_typesystem.md)
	  - [10.4.2. A Type Checker for SimPL](interp/simpl_typecheck.md)
	  - [10.4.3. Type Safety](interp/typesafety.md)
  - [10.5. Type Inference](interp/inference.md)
    - [10.5.1. Type Constraints](interp/constraints.md)
    - [10.5.2. Solving Constraints](interp/unification.md)
    - [10.5.3. Finishing Type Inference](interp/reconstruction.md)
    - [10.5.4. Let Polymorphism](interp/letpoly.md)
  - [10.6. Summary](interp/summary.md)
  - [10.7. Exercises](interp/exercises.md)

* [11. Proofs about Programs](fm/intro.md)
  - [11.1. Equality](fm/eq.md)
  - [11.2. Equational Reasoning](fm/eq_reasoning.md)
  - [11.3. Induction on Integers](fm/induction_int.md)
  - [11.4. Programs as Specifications](fm/prog_as_spec.md)
  - [11.5. Recursion vs Iteration](fm/rec_vs_it.md)
  - [11.6. Termination](fm/termination.md)
  - [11.7. Induction on Variants](fm/induction_variants.md)
    - [11.7.1. Induction on Naturals](fm/induction_nats.md)
    - [11.7.2. Induction on Lists](fm/induction_lists.md)
    - [11.7.3. A Theorem about Folding](fm/theorem_fold.md)
    - [11.7.4. Induction on Trees](fm/induction_trees.md)
    - [11.7.5. Induction Principles for All Variants](fm/induction_general.md)
  - [11.8. Algebraic Specification](fm/alg_spec.md)
    - [11.8.1. Example: Stacks](fm/alg_spec_stack.md)
    - [11.8.2. Example: Queues](fm/alg_spec_queue.md)
    - [11.8.3. Example: Two-List Queues](fm/alg_spec_tlqueue.md)
  - [11.9. Designing Algebraic Specifications](fm/alg_spec_eqs.md)
  - [11.10. Summary](fm/summary.md)
  - [11.11. Exercises](fm/exercises.md)

* [12. Advanced Topics](adv/intro.md)
  - [12.1. Infinite Data Structures](adv/infinite.md)
	- [12.1.1. Streams](adv/streams.md)
	- [12.1.2. Programming with Streams](adv/stream_progs.md)
	- [12.1.3. Laziness](adv/lazy.md)
  - [12.2. Concurrency](adv/concurrency.md)
	- [12.2.1. Promises](adv/promises.md)
	- [12.2.3. Asynchronous I/O](adv/asynch_io.md)
	- [12.2.4. Callbacks](adv/callbacks.md)
	- [12.2.5. Implementing Callbacks](adv/implementing_callbacks.md)
  - [12.3. Monads](adv/monads.md)
	- [12.3.1. Example: The Maybe Monad](adv/ex_maybe_monad.md)
	- [12.3.2. Example: The Writer Monad](adv/ex_writer_monad.md)
	- [12.3.3. Example: The Lwt Monad](adv/ex_lwt_monad.md)
	- [12.3.4. Monad Laws](adv/monad_laws.md)
  - [12.4. The Curry-Howard Correspondence](adv/curry-howard.md)
  - [12.5. Memoization](adv/memoization.md)
  - [12.6. Summary](adv/summary.md)
  - [12.7. Exercises](adv/exercises.md)
