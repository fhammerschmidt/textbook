# Compiling OCaml Programs

Using OCaml as a kind of interactive calculator can be fun, but we won't get
very far with writing large programs that way. We instead need to store code in
files and compile them.

## Storing code in files

Open a terminal and use a text editor to create a file called
`hello.ml`.  Enter the following code into the file:

```ocaml
let _ = print_endline "Hello world!"
```

```{note}
There is no double semicolon `;;` at the end of that line of code. The double
semicolon is intended for interactive sessions in the toplevel, so that the
toplevel knows you are done entering a piece of code. There's usually no reason
to write it in a .ml file.
```

The `let _ =` above means that we don't care to give a name (hence the "blank"
or underscore) to code on the right-hand side of the `=`.

Save the file and return to the command line.  Compile the code:

```console
$ ocamlc -o hello.byte hello.ml
```

The compiler is named `ocamlc`. The `-o hello.byte` option says to name the
output executable `hello.byte`. The executable contains compiled OCaml bytecode.
In addition, two other files are produced, `hello.cmi` and `hello.cmo`. We don't
need to be concerned with those files for now. Run the executable:

```console
$ ./hello.byte
```

It should print `Hello world!` and terminate.

Now change the string that is printed to something of your choice. Save the
file, recompile, and rerun. Try making the code print multiple lines.

This edit-compile-run cycle between the editor and the command line is something
that might feel unfamiliar if you're used to working inside IDEs like Eclipse.
Don't worry; it will soon become second nature.

Running the compiler directly is good to know how to do, but in larger projects,
we want to use the OCaml build system to automatically find and link in libraries.
Let's try using it:

```console
$ ocamlbuild hello.byte
```

You will get an error from that command. Don't worry; just keep reading this
exercise.

The build system is named `ocamlbuild`. The file we are asking it to build is
the compiled bytecode `hello.byte`. The build system will automatically figure
out that `hello.ml` is the source code for that desired bytecode.

However, the build system likes to be in charge of the whole compilation
process. When it sees leftover files generated by a direct call to the compiler,
as we did in the previous exercise, it rightly gets nervous and refuses to
proceed. If you look at the error message, it says that a script has been
generated to clean up from the old compilation. Run that script, and also remove
the compiled file:

```console
$ _build/sanitize.sh
$ rm hello.byte
```

After that, try building again:

```console
$ ocamlbuild hello.byte
```

That should now succeed. There will be a directory `_build` that is created; it
contains all the compiled code. That's one benefit of the build system over
directly running the compiler: instead of polluting your source directory with a
bunch of generated files, they get cleanly created in a separate directory.
There's also a file `hello.byte` that is created, and it is actually just a link
to "real" file of that name, which is in the `_build` directory.

Now run the executable:

```console
$ ./hello.byte
```

You can now easily clean up all the compiled code:

```console
$ ocamlbuild -clean
```

That removes the `_build` directory and `hello.byte` link, leaving just your
source code.

## What about Main?

Unlike C or Java, OCaml programs do not need to have a special function named
`main` that is invoked to start the program. The usual idiom is just to have the
very last definition in a file serve as the main function that kicks off
whatever computation is to be done.
